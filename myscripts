--[[
    PROFESSIONAL GRADE DAMAGE SPOOFER V2 (STEALTH)
    Bypass Method: C-Closure Hooking (Avoids __namecall detection)
    Protection: Anti-Kick Hook included
]]

local CONFIG = {
    MULTIPLIER = 100,      -- Damage Multiplier
    HITBOX = Vector3.new(15, 15, 15), -- Hitbox size (Keep reasonable to avoid distance checks)
    DEBUG = true           -- Show logs
}

-- // SERVICES \\ --
local Players = game:GetService("Players")
local LocalPlayer = Players.LocalPlayer
local StarterGui = game:GetService("StarterGui")

-- // 1. THE SAFETY NET: HOOK KICK() \\ --
-- We hook the Kick function associated with the LocalPlayer. 
-- If the game tries to kick you, we block it.
local old_kick
old_kick = hookfunction(LocalPlayer.Kick, newcclosure(function(self, ...)
    local args = {...}
    local msg = args[1] or "No message"
    
    warn("[ANTICHEAT BLOCKED] The game tried to kick you!")
    warn("Reason: " .. tostring(msg))
    
    -- Send a notification so you know it happened
    StarterGui:SetCore("SendNotification", {
        Title = "Kick Blocked";
        Text = "Anti-Cheat tried to kick you.";
        Duration = 5;
    })

    -- Return nothing (effectively cancelling the kick)
    return
end))

-- // 2. UI SETUP (Minimalist) \\ --
local ScreenGui = Instance.new("ScreenGui")
ScreenGui.Name = "StealthSpoofer"
ScreenGui.Parent = gethui and gethui() or game:GetService("CoreGui")

local Label = Instance.new("TextLabel")
Label.Size = UDim2.new(0, 200, 0, 30)
Label.Position = UDim2.new(0.5, -100, 0, 10)
Label.BackgroundColor3 = Color3.fromRGB(30, 30, 30)
Label.TextColor3 = Color3.fromRGB(0, 255, 100)
Label.Text = "STEALTH HOOK: ACTIVE"
Label.Parent = ScreenGui

-- // 3. THE STEALTH HOOK (FireServer) \\ --
-- Instead of hooking the metatable, we grab the C function directly from a dummy event.
local DummyEvent = Instance.new("RemoteEvent")
local FireServer = DummyEvent.FireServer
DummyEvent:Destroy()

local old_FireServer
old_kick = hookfunction(FireServer, newcclosure(function(self, ...)
    local args = {...}
    
    -- Check if the Remote being fired is the SwordDamage remote
    if self.Name == "SwordDamage" then
        
        -- ARGS MAPPING (Based on your dump):
        -- [1] = Target Humanoid
        -- [2] = Weapon Tool
        -- [3] = Damage Multiplier <-- TARGET
        -- [4] = Combo Count
        -- [5] = Hitbox Size <-- TARGET
        
        if CONFIG.DEBUG then
            Label.Text = "SPOOFED HIT: x" .. CONFIG.MULTIPLIER
            Label.TextColor3 = Color3.fromRGB(255, 50, 50)
            task.delay(0.5, function() 
                Label.Text = "STEALTH HOOK: ACTIVE" 
                Label.TextColor3 = Color3.fromRGB(0, 255, 100)
            end)
        end

        -- Apply Spoofs
        args[3] = CONFIG.MULTIPLIER
        
        if CONFIG.HITBOX then
            args[5] = CONFIG.HITBOX
        end
        
        -- Fire the original function with modified args
        return old_FireServer(self, unpack(args))
    end
    
    -- If it's not SwordDamage, let it pass through untouched
    return old_FireServer(self, ...)
end))

-- Store the original function reference so we can call it inside the hook
old_FireServer = old_kick 

print("[+] Stealth Hook Loaded. Anti-Kick Active.")
